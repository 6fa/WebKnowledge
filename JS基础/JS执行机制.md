# JS执行机制
JS引擎（即 JS解析器JavaScript Interpreter）在不同的宿主环境中执行流程都是基于Event Loop的，比如在浏览器和Node.js中。只是不同宿主环境基于不同的技术实现Event Loop。

从最基础的线程、进程开始说起：

### 进程 与 线程
- 进程（process）：

是CPU资源分配的最小单位，就是一个程序的运行实例，包括运行中的程序和程序使用的内存、系统资源。

- 线程（thread）：

是CPU最小调度单位，即程序中一个执行流，一个进程可以有多个线程。

比如打开微信，就是运行了一个进程；操作微信里面的支付、弹出一个聊天框等子任务，就是运行进程里面的线程。

- 多进程：

真正的并行执行多任务（进程）只能在多核CPU上实现，对于单核CPU想执行多任务，操作系统会轮流让各个任务交替执行。如果任务数量远超过CPU核心数量，操作系统把任务轮流调度到各个核心上执行。

- 多线程：

多线程和多进程执行方式一样，同样由操作系统在多个线程之间轮流切换，只有多核CPU才是真的同时并行执行。

### JS为什么是单线程
是因为JS是浏览器脚本语言，主要用于处理页面的交互、操作DOM树和CSS样式树等。如果有多个线程，某个线程增加一个节点的内容，某个线程删除了这个节点，浏览器不知以哪个为准。

为了利用多核CPU的计算能力，HTML5引入Web Worker为JS创建多线程环境。主线程可以创建子线程，在主线程运行的同时子线程在后台执行，完成计算任务后再返回给主线程。但是，子线程不能操作DOM树，且受主线程控制，并没有改变JS是单线程的本质。


### 为什么浏览器是多进程

#### 浏览器的组成部分
先来了解一下浏览器主要组成部分：
- 用户界面（User Interface）
- 浏览器引擎（Browser engine）- 在用户界面和呈现引擎之间传送指令
- 呈现引擎（Rendering engine，也称渲染引擎）- 负责显示请求的内容
- 网络(Networking) 
- 用户界面后端(UI Backend) - 用于绘制基本的窗口小部件
- JavaScript 解释器(JavaScript Interpreter) - 解析和执行JavaScript代码
- 数据存储(Data Persistence) - 浏览器在硬盘上保存数据

![browser](img/browser.png)


#### 呈现引擎
呈现引擎也称渲染引擎、浏览器内核，在线程方面又称为UI线程。

呈现引擎的基本工作流程：

![rendering](img/rendering.png)

从网络层获取请求的文档内容后，开始解析HTML文档，将各标记逐个转化成DOM树上的节点。同时解析外部CSS文件和元素中的样式数据，生成CSSOM（CSS Object Model，是一个建立在web页面上的 CSS 样式的映射），之后将DOM树和CSSOM树结合生成渲染树（render tree）。

![render-tree](img/render-tree-construction.png)

注意：渲染树只会包括需要显示的节点和节点样式，比如display：none的节点将不包括

渲染树构建完毕后进入布局阶段：为每个节点分配在屏幕中的确切坐标和大小（这一行为也称为自动重排）。

下一阶段是绘制，渲染引擎遍历渲染树，由用户界面后端将每个节点绘制出来。

再说一下常见的回流和重绘问题：
- 重绘：render tree中的元素只更新无关位置、大小的属性（比如背景色），不影响布局。
- 回流：render tree中元素尺寸规模、布局、隐藏等发生改变而使得render tree 重构。


#### JavaScript解析器
JavaScript解析器又称为JavaScript引擎，线程方面又称为JavaScript线程。

JS引擎会一直等待着任务队列中的任务到来，然后加以处理。注意浏览器中只有一个JS线程在执行JavaScript代码。

UI线程与JS引擎线程互斥，JS引擎线程执行时，会停止渲染线程。如果JS执行时间过长，则感觉到页面卡顿。

PS：对于静态语言来说（如Java、C++、C），处理上述这些事情的叫编译器（Compiler），相应地对于 JavaScript 这样的动态语言则叫解释器（Interpreter）。编译器是将源代码编译成另一种代码，比如机器码、字节码；解析器是将源代码直接解析并将运行结果输出。


#### 浏览器包含哪些进程
对于Chrome浏览器，打开一个Tab页面就产生一个进程。

浏览器包含的进程有：

1. Browser 进程

  - 主进程，只有一个。负责调控、协调；
  - 浏览器界面显示，与用户交互；
  - 各个页面的管理，创建和销毁其他进程；
  - 将渲染进程得到的内存中的位图（Bitmap），绘制到用户界面；
  - 网络资源的管理，比如下载等；

2. 第三方插件进程

  - 使用每种类型的插件时产生一个进程

3. GPU进程

  - 用于3D绘制等，只有一个

4. 渲染进程（renderer进程）

  - 内部是多线程；
  - 每个tab页面都有一个渲染进程，互不影响；
  - 主要进行页面渲染、脚本执行、事件处理等；


#### 浏览器的渲染进程
渲染进程是重点，它是多线程的，常用的主要线程有:

1. GUI渲染线程（即上面所说呈现引擎）
2. JS引擎线程（每个渲染进程只有一个JS线程，浏览器同时只能一个JS引擎线程在运行JS）
3. 事件触发线程

  控制事件循环，管理着一个事件队列（task queue）。

  当JS执行碰到事件绑定、异步操作（setTimeout，或者来自其他浏览器线程，如鼠标点击、异步请求）等，事件触发线程会将对应的事件添加到对应线程中。

  当异步事件有了结果，会将回调添加到事件队列。

4. 定时触发器线程

  定时器（setTimeout、setInterval）所在线程，由单独的定时触发器线程计时，而不是JS线程计时，因为JS线程可能发生堵塞，则影响计时准确。

  计时完成后，添加到事件触发线程的事件队列中。

  setTimeout中低于4ms的时间间隔算4ms（W3C在HTML标准中规定）

5. 异步http请求线程

  当JS执行到异步请求时，事件触发线程将其添加到此线程，等http状态变化时（如收到响应），再把回调添加到事件队列等待JS执行



#### 为什么浏览器是多进程
如果浏览器是单进程，那么其中某个tab页面奔溃会影响到整个浏览器。某些浏览器进程里面又包含许多线程，因为一些任务是非常耗时的（比如网络请求、定时器、事件监听等），如果像单线程一样一件一件执行效率会非常低。



### 事件循环（Event Loop）
JS任务可以分为同步任务（synchronous）、异步任务（asynchronous）：
- 同步任务在主线程（即JS引擎线程）执行，形成一个执行栈
- 碰到异步任务时，只要异步任务有了运行结果，其回调函数会被放到事件触发线程管理着的事件队列
- 等主线程空闲下来时，系统读取事件队列并添加到执行栈中，开始执行

JS引擎线程执行处于执行栈中的任务，等空闲后就读取事件队列中的事件，将其添加到执行栈并执行，如此循环，也就是Event Loop。


### 宏任务（macrotask/task）与微任务（microtask）
JS任务除了可以分为同步任务、异步任务外，还可以分为宏任务、微任务。

（注意这两个分类的联系：同步任务可以看作宏任务，异步任务又可以分为宏任务、微任务）

先看个例子：
```javascript
console.log("1");

new Promise((resolve)=>{
  console.log("2")
  resolve()
}).then(()=>{
  console.log("3")
});

setTimeout(()=>{
  console.log("4")
},0);

console.log("5")
```

上面代码执行结果是：1    2    5    3    4

注意new Promise()是同步的，所以立即执行了；Promise.then()和setTimeout()是异步的，所以后执行。

那么为什么Promise.then()比setTimeout()先执行呢？

因为setTimeout属于宏任务，Promise.then()属于微任务。

#### 宏任务
宏任务一般包括：
- 主代码块
- setTimeout
- setInterval
- setImmediate    (仅Node)
- requestAnimationFrame    (仅浏览器)

由于JS引擎线程和渲染线程是互斥的，为了避免页面卡顿，会在宏任务执行后进行渲染，然后执行下一宏任务。

第一个宏任务即执行主线程上的JS代码，如果遇到上面的异步宏任务，会创建新的宏任务队列。


#### 微任务
微任务一般包括：
- process.nextTick    （仅Node）
- Promise.then    
- catch
- finally
- Object.observe
- MutationObserver

微任务可以理解为宏任务执行完毕后立即执行的任务，因此完整的任务执行流程为：

宏任务->微任务->渲染->宏任务......

以一个例子理解上面的流程：
```javascript
document.body.style = 'background:blue'
console.log(1);
Promise.resolve().then(()=>{
    console.log(2);
    document.body.style = 'background:pink'
});
console.log(3);
```

执行顺序：
1. 首先执行第一个宏任务——主代码块，输出1和3
2. 执行微任务Promise.then()里面的内容，输出2
3. 渲染，此时背景为粉红。因为一开始宏任务里的背景色被后来微任务里的背景色覆盖了。


#### 注意点
- 宏任务和微任务不在一个队列。
- 从宏任务队列里面取出一个宏任务，执行完，会检查、执行微任务队列里面的所有微任务。
- 微任务里面还有微任务的，会等所有微任务执行完再执行下一宏任务。
- 微任务里面创建了宏任务，宏任务会被追加到宏任务队列里面。
- 关于async/await可以理解为：await语句紧跟的及之前的代码相当于new Promise，之后的代码相当于Promise.then

#### 完整的Event Loop
1. 整体script代码中的同步任务（作为第一个宏任务）进入主线程执行
2. 异步任务可以分为宏任务和微任务，各自有自己的任务队列
3. 第一个宏任务执行完，会将微任务事件队列中所有任务添加到执行栈执行
4. 接下来渲染
5. 然后再从宏任务队列中取出一个宏任务，添加到执行栈执行，如此反复

Node中的Event Loop和上面有些不同，更复杂些。


### 参考
1. [这一次，彻底弄懂 JavaScript 执行机制](https://juejin.im/post/6844903512845860872)
2. [聊聊 JavaScript 与浏览器的那些事 - 引擎与线程](https://zhuanlan.zhihu.com/p/32751855)
3. [「硬核JS」一次搞懂JS运行机制](https://juejin.im/post/6844904050543034376)
4. [进程和线程 - 廖雪峰](https://www.liaoxuefeng.com/wiki/1016959663602400/1017627212385376)
5. [10分钟了解JS堆、栈以及事件循环的概念](https://juejin.im/post/6844903618999500808)