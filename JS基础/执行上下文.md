# 执行上下文

## 概念
执行上下文（execution context 简称 EC）即代码运行的环境，每当JS运行时，都是在执行上下文中运行的。主要记录了代码执行过程中的状态信息，如：
- 变量对象的定义
- 作用域链的扩展
- 提供调用者的对象引用等信息

代码结束时，执行上下文也会销毁。

## 执行上下文栈 & Event Loop执行机制
- 执行栈（call stack）是用来存放不同执行上下文的栈结构（LIFO后进先出），因为脚本运行时可能会调用很多函数而产生很多函数执行上下文，统一交由执行栈管理。
- 执行栈的容量是有限的，如果积压到一定程度继续积压，会报“栈溢出”（stack overflow）错误。栈溢出错误常发生在递归（调用自身）中。
- Event Loop事件循环是JS的执行机制。因为js引擎线程是单线程的，为了合理地安排同步任务和异步任务的执行，定义了事件循环机制来协调。Event Loop会先执行完处于执行栈中的任务后，然后从事件队列读取事件，添加到执行栈中执行，如此循环。

## 执行上下文分类
根据不同的运行场景，执行上下文分为：
- 全局执行上下文
  - js代码开始的默认运行环境，在整个js脚本的生命周期中一直存在于执行堆栈的最底部不会被栈弹出销毁
  - 全局上下文会生成一个全局对象（浏览器中是window，node中是global）
  - 将this指向全局对象
- 函数执行上下文
  - 函数调用时创建
  - 不管函数调用几次，每次调用都会生成新的上下文
- eval执行上下文
  - eval函数执行时，会有属于它自己的执行上下文

## 执行上下文生命周期
### 创建阶段
- 初始化变量对象
  - 如果是函数执行上下文，会以参数列表(arguments)初始化变量对象，以及将函数内部的变量声明、函数声明添加到变量对象。
  - 在这一阶段，会进行变量和函数的初始化声明，变量定义为undefined，而函数直接定义。即变量提升，变量和函数都会提升，但函数会更靠前。
```javascript
  //变量提升中，函数更靠前,所以会被同名的变量覆盖
  var a = 2
  function a(){
  }
  console.log(a); //2
```
- 构建作用域链
- 确定this值

### 执行阶段
JS代码开始逐句执行，顺着作用域链访问变量、为之前声明的变量赋值、碰到函数调用则创建新的函数执行上下文压入栈中，并把控制权交出。

### 销毁阶段
一般情况下，函数执行完成后，会将当前上下文弹出执行栈进行销毁，将控制权交回给上一层的执行上下文。但是闭包的情况有所不同。

当包裹闭包函数的父函数执行完毕后，父函数本身执行环境的作用域链被销毁，但是由于闭包函数有对父函数变量的引用，导致父函数的变量对象一直存在于内存，无法被销毁，除非闭包的引用被删除。

过多使用闭包导致不再用到的内存，没有及时释放，有可能发生“内存泄露”。


## ES3执行上下文的内容
在ES3的定义中，执行上下文包括：
  - 变量对象 （variable object 简称 VO）
  - 活动对象 （activation object 简称 AO）
  - 作用域链（scope chain）
  - 调用者信息 （this）

### 变量对象
在全局执行上下文中，变量对象即全局对象，以浏览器来说即window。通过var定义的全局变量或函数都会成为window的属性和方法，但是let和const的顶级声明不会。

在函数执行上下文中，变量对象会包含函数的参数列表(arguments)，及函数内部声明的变量、函数（注意是函数声明会加入变量对象，函数表达式不会）。但是不能被直接访问到，需等函数调用时，VO变为AO。

```javascript
//函数声明
function a = {}

//函数表达式
//b是变量声明，会加入变量对象
//foo是函数表达式，会被忽略
let b = function foo(){}
```

### 活动对象
函数调用时，函数上下文的变量对象转变为活动对象。其实变量对象和活动对象是一个东西，只不过处于不同的状态和阶段而已。

### 作用域链
作用域规定如何查找变量，即当前执行代码对变量的访问权限。

创建执行上下文时，会为变量对象创建作用域链：当查找变量时，如果不存在于当前上下文的变量对象，则会往上一级上下文中的变量对象中查找，一直到全局上下文。这样由多级上下文的变量对象构成的链表，称为作用域链。

函数在创建时已经确定作用域：创建一个scope的内部属性保存所有父变量对象；当函数执行时，创建执行上下文，则会复制scope来构建作用域链，然后将VO转变为AO并添加到作用域链前端。

### 调用者信息
this是执行上下文创建时会创建的一个属性，this绑定的对象取决于函数调用的条件。
  - 直接使用不带任何修饰的函数引用进行调用，则绑定到window【默认规则】
  - 调用位置有上下文对象，则this绑定到那个上下文对象【隐式绑定】
  - 使用call、apply、bind显式绑定 【显式绑定】
  - 使用new操作符将this绑定到新对象 【new绑定】
  - 箭头函数的this不适用上面的规则，而是根据外层作用域绑定：会等于外层函数的this或全局对象

### 数据结构模拟
如果用代码将执行上下文表达出来：
```javascript
executionContext：{
    [variable object | activation object]：{
        arguments,
        variables: [...],
        funcions: [...]
    },
    scope chain: variable object + all parents scopes
    thisValue: context object
}
```