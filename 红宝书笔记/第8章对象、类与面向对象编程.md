# 对象、类与面向对象编程

## 1.对象属性类型
- 数据属性：包含一个保存数据值的位置。数据数据有4个内部特性/属性描述符来描述它：
  - configurable：是否可配置。即属性是否能被delete、重新定义、修改特性、变成访问器属性
  - Enumberable：是否可枚举。即是否能通过for-in循环返回
  - Writable：属性值是否可被修改。
  - Value：包含属性实际的值。默认值为undefined
- 访问器属性：不包含数据值，包含一个获取（getter）函数和设置（setter）函数。同样有4个属性描述符：
  - configurable
  - Enumberable
  - Get
  - Set

## 2.定义、读取对象属性
- 定义属性：Object.defineProperty
- 读取属性的特性：Object.getOwnPropertyDescriptor()

## 3.ES6：属性值简写、可计算属性、简写方法名、对象解构
- 属性值简写：当变量名和属性名一样时，可以只写变量名
- 可计算属性：
  - 在引入可计算属性之前，想**用变量值来命名属性**时，先声明对象，然后使用中括号语法添加属性
  ```javascript
  let person = {}
  let key = "name"
  person[key] = "Jack"
  ```
  - 使用可计算属性，在对象字面量中直接完成动态属性赋值。**中括号里面的内容会被看作js表达式**而不是字符串，因此括号里面可以是复杂的表达式
  ```javascript
  let key = "name"
  let person = {
    [key]:"Jack"
  }
  ```

- 简写方法名：定义对象方法时，不用属性名+匿名函数的形式
```javascript
let person = {
  sayName(){}
  get name(){} //getter、setter函数也适用
	set name(){}
}
```

- 对象解构：可以在一条语句中使用嵌套数据实现一个或多个赋值操作（使用与对象匹配的结构来实现对象属性赋值）
```javascript
let person= {
  name:"Jack",
  age:18
}

//对象解构
let {name:personName, age:personAge} = person
console.log(personName) //"Jack"


//简写
let {name, age} = person
console.log(name) //"Jack"


//设置默认值
let {name = "Rose", age, gender = "women"} = person
console.log(name) //"Jack"
console.log(gender) //"women" 只有原对象中没有的属性，默认值才起作用


//给事先声明的变量赋值，赋值表达式要包含在括号中
let personName,personAge;
({name:personName, age:personAge} = person)

let newObj = {}
({name:newObj.name, age:newObj.age} = person)


//嵌套解构
let person = {
  name:"Matt",
  age:18,
  job:{
    title:"Software engineer"
  }
}
let {job:{title:jobTiltle}} = person

```

## 4.合并对象、相等判定
- Object.assign()：将源对象每个可枚举属性复制（浅复制）到目标对象。返回修改后的目标对象。
- Object.is()：与严格相等很像，但是有一些情况不同
```javascript
	// 对于true/false
console.log(true == 1) //true
console.log(true === 1) //false
console.log(Object.is(true,1)) //false

	//对于-0，+0，0
console.log(0 == -0) //true
console.log(+0 == -0) //true

console.log(0 === -0) //true
console.log(+0 === -0) //true

console.log(Object.is(0,-0)) //false   这里和===不同
console.log(Object.is(+0,-0)) //false
console.log(Object.is(0,+0)) //true   注意这个

	//对于null、undefined
console.log(null == undefined) //true
console.log(null === undefined) //false
console.log(Object.is(null,undefined)) //false

	//对于NaN
console.log(NaN == NaN) //false
console.log(NaN === NaN) //false
console.log(Object.is(NaN,NaN)) //true  注意这个
```

## 5.创建对象的方式
#### 5.1.工厂模式
- 工厂模式是一个简单的函数，函数创建一个对象，给对象添加属性和方法，然后返回这个对象。
- 缺点：这种模式虽然可以解决创建多个类似对象的问题，但是没有解决对象标识问题（即新创建的对象是什么类型）
```javascript
fucntion createPerson(name,age){
  let o = {};
  o.name = name;
  o.age = age;
  o.sayname = fucntion(){
    console.log(this.name)
  };
  return o
}
let p1 = createPerson("jack",29)
```

#### 5.2.构造函数模式
- 相比工厂模式，可以确保实例被标识为特定类型（p1.constructor == Person）
- 它的问题是，其定义的方法会在每个实例上创建一遍（可以通过原型模式来解决）
```javascript
function Person(name,age){
  this.name = name
  this.age = age
  this.sayname = fucntion(){
    console.log(this.name)
  }
}

let p1 = new Person("jack",29)
```
#### 5.3.原型模式
- 使用原型的好处就是，它上面的属性和方法可以被对象实例共享
- 正常的原型链终止于Object的原型对象（Object.prototype）
- Object.prototype的原型是null（Object.prototype._ proto_ == null）
- 常用方法：isPrototypeOf()、Object.getPrototypeOf()、Object.setPrototypeOf()
- **Object.setPrototypeOf()会影响代码性能**，可以使用Object.create: 
```javascript
//创建一个新对象，并为其指定原型
let newPerson = Object.create(person)
// newPerson.__proto__ == person


Object.setPrototypeOf(newPerson,person)
newPerson.__proto__ === person //true
Object.getPrototypeOf(newPerson) === person //true
person.isPrototypeOf(newPerson)       //true
```
- 判断属性是在实例上还是原型对象上：hasOwnProperty()
- 而**for-in**无论是原型上还是实例上的属性（可枚举）都会返回
- **原型的动态性**：任何时候对原型的改变也会反映在实例上。这是因为实例和原型之间的链接是简单的指针
```javascript
function Person(){}
let friend = new Person()
Person.prototype.sayHi = function(){
  console.log("Hi")
}
friend.sayHi()
//即使sayHi是在创建实例之后添加的，但是依然可以访问到
```

- 但是**重写整个原型时**（创建实例之后重写），情况不一样：实例引用的依然是最初的原型
```javascript
function Person(){}
let friend = new Person()
Person.prototype = {
  constructor: Person,
  sayHi(){
    console.log("Hi")
  }
}
friend.sayHi()
//Uncaught TypeError: friend.sayHi is not a function
```

- 原型的问题：共享特性。对于包含引用值的属性，一个实例对其修改，会在其他实例上反映出来。这也是不单独使用原型模式的原因。（因此属性会在构造函数中定义而不是原型）